# Number

## 一个整数的二进制表示

### 原码
第一位作为`符号位`存在，所以如果用 8 位去表示整数那么可以表示的范围有
```
[00000000, 01111111] => 0 <= x <= 127
[11111111, 00000000) => -127 <= x < 0
```
即 [-127, 127]
原码是`人类`最容易理解和计算的表示方式

### 反码
正数的反码 == 正数的原码
负数的反码 == 负数的原码 + 符号位不变 + 其他`按位取反`
```
[10000001]原 => [11111110]反
```
相当于`值部分` => MAX - CUR (1111111 - 0000001 = 1111110)

### 补码
正数的补码 == 正数的反码 == 正数的原码
负数的补码 == 负数的原码 + 符号位不变 + 其他`按位取反` + 1
```
[10000001]原 => [11111110]反 => [11111111]补
```
负数的补码和反码已经不太适合人类直观的看出数值，需要经过一系列转换

### 为什么需要反码和补码
当人类在计算二进制的减法时，因为可以直接识别符号位，所以在实施计算的时候会不自觉返回十进制进行计算再进行转换。
但是机器无法做到，为了保持机器的电路设计简单（意味着只有`加法`），人们开始探求符号位参与加法计算的方式。

当使用`原码`的时候，结果是错误的，因为计算机只能做加法，使用十进制来理解就是
```
-1 + 1 = -2 (因为计算机只知道 1 + 1 = 2)
```

当使用`反码`的时候，结果是正确的，但是会出现`正负 0`的问题
当使用`补码`的时候，可以避免正负 0 的问题，并且能够多表示一个负数（用于取代之前负0的编码）







